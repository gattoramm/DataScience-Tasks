## Using iterators in PythonLand
Here, you'll learn all about iterators and iterables, which you have already worked with before when writing for loops! You'll learn about some very useful functions that will allow you to effectively work with iterators and finish the chapter with a use case that is pertinent to the world of Data Science - dealing with large amounts of data - in this case, data from Twitter that you will load in chunks using iterators!

### Iterators vs Iterables
Let's do a quick recall of what you've learned about **iterables** and **iterators**. Recall from the video that an *iterable* is an object that can return an *iterator*, while an *iterator* is an object that keeps state and produces the next value when you call `next()` on it. In this exercise, you will identify which object is an iterable and which is an *iterator*.

The environment has been pre-loaded with the variables `flash1` and `flash2`. Try printing out their values with `print()` and `next()` to figure out which is an *iterable* and which is an *iterator*.

### Iterating over iterables (1)
Great, you're familiar with what iterables and iterators are! In this exercise, you will reinforce your knowledge about these by iterating over and printing from iterables and iterators.

You are provided with a list of strings `flash`. You will practice iterating over the list by using a `for` loop. You will also create an iterator for the list and access the values from the iterator.

### Iterating over iterables (2)
One of the things you learned about in this chapter is that not all iterables are *actual* lists. A couple of examples that we looked at are *strings* and the use of the `range()` function. In this exercise, we will focus on the `range()` function.

You can use `range()` in a `for` loop as *if* it's a list to be iterated over:

```python
for i in range(5):
  print(i)
```

Recall that `range()` doesn't actually create the list; instead, it creates a range object with an iterator that produces the values until it reaches the limit (in the example, until the value 4). If `range()` created the actual list, calling it with a value of 10<sup>100</sup> may not work, especially since a number as big as that may go over a regular computer's memory. The value 10<sup>100</sup> is actually what's called a **Googol** which is a 1 followed by a hundred 0s. That's a huge number!

Your task for this exercise is to show that calling `range()` with 10<sup>100</sup> won't actually pre-create the list.

### Iterators as function arguments
You've been using the `iter()` function to get an iterator object, as well as the `next()` function to retrieve the values one by one from the iterator object.

There are also functions that take iterators and iterables as arguments. For example, the `list()` and `sum()` functions return a list and the sum of elements, respectively.

In this exercise, you will use these functions by passing an iterable from `range()` and then printing the results of the function calls.

### Using enumerate
You're really getting the hang of using iterators, great job!

You've just gained several new ideas on iterators from the last video and one of them is the `enumerate()` function. Recall that `enumerate()` returns an `enumerate` object that produces a sequence of tuples, and each of the tuples is an *index*-*value* pair.

In this exercise, you are given a list of strings `mutants` and you will practice using `enumerate()` on it by printing out a list of tuples and unpacking the tuples using a `for` loop.

### Using zip
Another interesting function that you've learned is `zip()`, which takes any number of iterables and returns a `zip` object that is an iterator of tuples. If you wanted to print the values of a `zip` object, you can convert it into a list and then print it. Printing just a `zip` object will not return the values unless you unpack it first. In this exercise, you will explore this for yourself.

Three lists of strings are pre-loaded: `mutants`, `aliases`, and `powers`. First, you will use `list()` and `zip()` on these lists to generate a list of tuples. Then, you will create a `zip` object using `zip()`. Finally, you will unpack this `zip` object in a `for` loop to print the values in each tuple. Observe the different output generated by printing the list of tuples, then the `zip` object, and finally, the tuple values in the `for` loop.

### Using * and zip to 'unzip'
You know how to use `zip()` as well as how to print out values from a `zip` object. Excellent!

Let's play around with `zip()` a little more. There is no *unzip* function for doing the reverse of what `zip()` does. We can, however, reverse what has been `zip` ped together by using `zip()` with a little help from `*`!`*` unpacks an *iterable* such as a list or a tuple into positional arguments in a function call.

In this exercise, you will use `*` in a call to `zip()` to unpack the tuples produced by `zip()`.

Two tuples of strings, `mutants` and `powers` have been pre-loaded.

### Processing large amounts of Twitter data
Sometimes, the data we have to process reaches a size that is too much for a computer's memory to handle. This is a common problem faced by data scientists. A solution to this is to process an entire data source chunk by chunk, instead of a single go all at once.

In this exercise, you will do just that. You will process a large csv file of Twitter data in the same way that you processed `'tweets.csv'` in [Bringing it all together]() exercises of the prequel course, but this time, working on it in chunks of 10 entries at a time.

If you are interested in learning how to access Twitter data so you can work with it on your own system, refer to [Part 2]() of the DataCamp course on Importing Data in Python.

The pandas package has been imported as pd and the file `'tweets.csv'` is in your current directory for your use. Go for it!

### Extracting information for large amounts of Twitter data
Great job chunking out that file in the previous exercise. You now know how to deal with situations where you need to process a very large file and that's a very useful skill to have!

It's good to know how to process a file in smaller, more manageable chunks, but it can become very tedious having to write and rewrite the same code for the same task each time. In this exercise, you will be making your code more *reusable* by putting your work in the last exercise in a *function definition*.

The pandas package has been imported as `pd` and the file `'tweets.csv'` is in your current directory for your use.
